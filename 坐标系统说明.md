# 八邻域图像处理坐标系统说明

## 📌 图像坐标系统基础

```
imo[row][col] 图像坐标系
┌─────────────────┐
│  row=0  (顶部)  │  ← 屏幕上方
│                 │
│      ↓          │
│   (增长方向)    │
│      ↓          │
│                 │
│  row=119(底部)  │  ← 屏幕下方
└─────────────────┘
   col=0 → col=187
   (左)      (右)
```

## 1️⃣ 生长方向 (`dir_l[]` / `dir_r[]`)

### 方向编码（八邻域）
- **左线顺时针**: `{0,1}, {-1,1}, {-1,0}, {-1,-1}, {0,-1}, {1,-1}, {1,0}, {1,1}`
- **右线逆时针**: `{0,1}, {1,1}, {1,0}, {1,-1}, {0,-1}, {-1,-1}, {-1,0}, {-1,1}`

```
方向索引与屏幕位置关系：
        0 = 向下 (y+1)  ↓
      7   1
    6   ●   2
      5   3
        4 = 向上 (y-1)  ↑
```

### 索引增长方向
```
dir_l[0] → dir_l[1] → dir_l[2] → ...
  ↑起点(底部)              ↑终点(顶部)
  
时间顺序：从屏幕底部往上爬取
```

**关键点**：
- ✅ `dir_l[0]` = 起点（底部，y≈117）的生长方向
- ✅ 索引增大 = 时间推进 = **向屏幕上方**爬取
- ✅ `dir_l[i] = 4` 表示该点向上生长（y减小）

---

## 2️⃣ 原始边界点 (`points_l[][]` / `points_r[][]`)

### 坐标存储格式
```c
points_l[i][0] = x;  // 横坐标 (0~187)
points_l[i][1] = y;  // 纵坐标 (0~119)，使用图像原始坐标
```

### 索引增长方向
```
图像坐标 (imo原始)        points_l数组索引
┌────────────┐ y=0         points_l[300] ← 终点(顶部)
│            │                   ↑
│   生长路径 │                   │
│      ↑     │              (索引增大方向)
│      │     │                   │
│   起点     │             points_l[0]   ← 起点(底部)
└────────────┘ y=119
```

**关键点**：
- ✅ `points_l[0]` = 起点坐标（y≈117，底部）
- ✅ `points_l[i][1]` 随索引增大而**减小**（y值从大→小）
- ✅ 索引增大 = **向屏幕上方**移动
- ✅ 坐标值使用图像原始坐标系（y越小越靠上）

---

## 3️⃣ 提取边界数组 (`l_border[]` / `r_border[]`)

### 数组索引规则
```c
// 在 get_left() 中进行了行号反转
uint16_t row = image_h - 1 - points_l[j][1];  // 反转！
l_border[row] = col;
```

### 索引增长方向
```
l_border数组索引         对应屏幕位置
l_border[0]     ←→    屏幕顶部 (imo的y=119)
l_border[1]     ←→    ↓
l_border[2]     ←→    ↓
    ...              (向下)
l_border[118]   ←→    ↓
l_border[119]   ←→    屏幕底部 (imo的y=0)
```

### 反转对照表
| `points_l[j][1]` (原始y) | 转换后 `row` | `l_border[]` 索引 | 屏幕位置 |
|:------------------------:|:------------:|:-----------------:|:--------:|
| 0 (图像顶部)             | 119          | 119               | 底部     |
| 60 (图像中部)            | 59           | 59                | 中部     |
| 119 (图像底部)           | 0            | 0                 | 顶部     |

**关键点**：
- ✅ `l_border[0]` = 屏幕**顶部**的边界x坐标
- ✅ 索引增大 = **向屏幕下方**
- ✅ 反转的目的：让数组下标小的元素对应图像上方，符合"从下往上处理"的逻辑

---

## 4️⃣ 中线数组 (`center_line[]`)

### 索引方向
```c
center_line[i] = (l_border[i] + r_border[i]) >> 1;
```

**继承 `l_border` 的索引规则**：
- ✅ `center_line[0]` = 屏幕顶部的中线x坐标
- ✅ 索引增大 = **向屏幕下方**

---

## 5️⃣ 绘制时的坐标转换

### 当前绘制代码
```c
// 绘制原始points（完全体）
imo[row][col] = 1;  // 直接使用 points_l 的原始坐标

// 绘制中线
imo[image_h - row][center_line[row]] = 3;  // 再次反转
```

### 坐标流转全过程
```
八邻域爬取 → points_l[i][1] (y从大→小)
    ↓
提取边界  → row = 119 - y (反转)
    ↓
l_border[row] (索引从小→大 = 屏幕从上→下)
    ↓
绘制显示  → imo[119-row] (再次反转回原始坐标)
```

---

## 📊 对比总结表

| 数据结构 | 索引0位置 | 索引增大方向 | 存储坐标系 | 用途 |
|:--------:|:--------:|:----------:|:----------:|:----:|
| `dir_l[]` | 起点(底部) | ↑屏幕上方 | 方向编码 | 生长方向序列 |
| `points_l[][]` | 起点(底部) | ↑屏幕上方 | 图像原始坐标(y大→小) | 完整边界点集 |
| `l_border[]` | 屏幕顶部 | ↓屏幕下方 | 反转后坐标 | 每行的边界x值 |
| `center_line[]` | 屏幕顶部 | ↓屏幕下方 | 反转后坐标 | 每行的中线x值 |

---

## 🔧 实际应用示例

### 示例1：判断生长是否向上
```c
// dir_l[i] = 4 表示向上生长（y-1方向）
if (dir_l[i] == 4) {
    // 说明该点在向屏幕上方爬取
}
```

### 示例2：访问特定高度的边界
```c
// 要访问屏幕上方1/3处的左边界
int target_row = image_h / 3;  // l_border索引40（对应imo的y=79）
uint8_t left_x = l_border[target_row];
```

### 示例3：遍历从底到顶的边界
```c
// 使用 l_border 遍历（从顶到底）
for (int row = 0; row < image_h; row++) {
    // row=0是屏幕顶部，row=119是屏幕底部
}

// 使用 points_l 遍历（从底到顶）
for (int i = 0; i < data_stastics_l; i++) {
    // i=0是起点(底部)，i=max是终点(顶部)
    // 但 points_l[i][1] 是递减的
}
```

---

## ⚠️ 注意事项

1. **坐标系混用风险**：
   - `points_l` 使用原始图像坐标
   - `l_border` 使用反转后的索引
   - 绘制时需要注意转换关系

2. **丢线判断**：
   - `l_border[row] == border_min` 且 `left_lost[row] == 1` = 该行左线丢失
   - `r_border[row] == border_max` 且 `right_lost[row] == 1` = 该行右线丢失

3. **十字补线**：
   - `break_num` 使用的是 `points_l[i][1]`（原始y坐标）
   - 补线时操作的是 `l_border[]`（反转后索引）
   - 需要注意坐标转换

---

## 📝 版本信息

- **文件**: `image.c`
- **分支**: RE0with8neighbor
- **日期**: 2025年10月25日
- **说明**: 本文档描述八邻域边界提取算法的坐标系统设计
