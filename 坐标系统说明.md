# 八邻域图像处理坐标系统说明

## 📌 图像坐标系统基础

```
imo[row][col] 图像坐标系
┌─────────────────┐
│  row=0  (顶部)  │  ← 屏幕上方
│                 │
│      ↓          │
│   (增长方向)    │
│      ↓          │
│                 │
│  row=119(底部)  │  ← 屏幕下方
└─────────────────┘
   col=0 → col=187
   (左)      (右)
```

## 1️⃣ 生长方向 (`dir_l[]` / `dir_r[]`)

### 八邻域种子定义
```c
// 左线：顺时针搜索（从上开始，顺时针旋转）
static int8_t seeds_l[8][2] = {
    {0,  1},   // 0: 向下
    {-1, 1},   // 1: 左下
    {-1, 0},   // 2: 向左
    {-1,-1},   // 3: 左上
    {0, -1},   // 4: 向上  ← 主要生长方向
    {1, -1},   // 5: 右上
    {1,  0},   // 6: 向右
    {1,  1}    // 7: 右下
};

// 右线：逆时针搜索（从上开始，逆时针旋转）
static int8_t seeds_r[8][2] = {
    {0,  1},   // 0: 向下
    {1,  1},   // 1: 右下
    {1,  0},   // 2: 向右
    {1, -1},   // 3: 右上
    {0, -1},   // 4: 向上  ← 主要生长方向
    {-1,-1},   // 5: 左上
    {-1, 0},   // 6: 向左
    {-1, 1}    // 7: 左下
};
```

### 方向编码可视化（左右对比）

```
┌─────────── 左线(顺时针) ───────────┐    ┌─────────── 右线(逆时针) ───────────┐
│                                     │    │                                     │
│          向上 (4) ← 主方向          │    │          向上 (4) ← 主方向          │
│            ↑                        │    │            ↑                        │
│      (3)  │  (5)                   │    │      (5)  │  (3)                   │
│   左上 ╲  │  ╱ 右上                 │    │   左上 ╲  │  ╱ 右上                 │
│         ╲ │ ╱                       │    │         ╲ │ ╱                       │
│   (2) ←── ● ──→ (6)                │    │   (6) ←── ● ──→ (2)                │
│   向左    │    向右                 │    │   向左    │    向右                 │
│         ╱ │ ╲                       │    │         ╱ │ ╲                       │
│   左下 ╱  │  ╲ 右下                 │    │   左下 ╱  │  ╲ 右下                 │
│      (1)  │  (7)                   │    │      (7)  │  (1)                   │
│            ↓                        │    │            ↓                        │
│          向下 (0)                   │    │          向下 (0)                   │
│                                     │    │                                     │
│  搜索: 0→1→2→3→4→5→6→7(顺时针)     │    │  搜索: 0→1→2→3→4→5→6→7(逆时针)     │
│  优先: 4(向上) 5(右上)              │    │  优先: 4(向上) 5(左上)              │
│  右转: 方向值↑ (4→5→6)              │    │  左转: 方向值↑ (4→5→6)              │
│  左转: 方向值↓ (4→3→2)              │    │  右转: 方向值↓ (4→3→2)              │
│                                     │    │                                     │
└─────────────────────────────────────┘    └─────────────────────────────────────┘

关键区别：
  左线                          右线
  ├─ 右侧编号大: 5,6,7          ├─ 左侧编号大: 5,6,7
  ├─ 顺时针旋转搜索             ├─ 逆时针旋转搜索
  ├─ 优先右上方向(5)            ├─ 优先左上方向(5)
  └─ 跟踪道路左侧边界           └─ 跟踪道路右侧边界
```

### 左右线生长规律

#### **左线（顺时针）特征**
```
正常向上爬取时的典型序列：
4→4→4→4→5→4→4→...  (主要是向上和右上)

遇到左弯道时：
4→3→3→2→2→...      (向上→左上→向左)

遇到右弯道时：
4→5→5→6→6→...      (向上→右上→向右)

开始向下时（异常）：
7→0→0→...          (右下→向下)
```

#### **右线（逆时针）特征**
```
正常向上爬取时的典型序列：
4→4→4→4→5→4→4→...  (主要是向上和左上)

遇到右弯道时：
4→3→3→2→2→...      (向上→右上→向右)

遇到左弯道时：
4→5→5→6→6→...      (向上→左上→向左)

开始向下时（异常）：
7→0→0→...          (左下→向下)
```

### 生长方向判断准则

#### **正常向上生长**
- `dir_l[i] = 4` 或 `dir_l[i] = 5`：左线正常向上或右上
- `dir_r[i] = 4` 或 `dir_r[i] = 5`：右线正常向上或左上

#### **弯道识别**
```c
// 左弯道特征（连续向左生长）
// 左线: 3,3,3 或 2,2,2
// 右线: 较多的 4 和 5（持续向上-左上）

// 右弯道特征（连续向右生长）
// 左线: 较多的 4 和 5（持续向上-右上）
// 右线: 3,3,3 或 2,2,2

// 十字路口特征 (arr.up_inner)
// 左右两边都是: 5,5,5,7,7,7（向上后开始向下）
```

#### **异常状态**
```c
// 左线开始向下（代码第267行检测）
if (dir_l[l_data_statics - 1] == 7 
    && points_r[r_data_statics][1] > points_l[l_data_statics - 1][1]) {
    // 左线右下(7)且左线比右线高 → 等待右边
}

// 向下生长 (0,1,7) 通常表示：
// - 十字路口上半部分
// - 环岛入口
// - 边界丢失后的错误生长
```

### 索引增长方向
```
dir_l[0] → dir_l[1] → dir_l[2] → ...
  ↑起点(底部)              ↑终点(顶部)
  
时间顺序：从屏幕底部往上爬取
```

**关键点**：
- ✅ `dir_l[0]` = 起点（底部，y≈117）的生长方向
- ✅ 索引增大 = 时间推进 = **向屏幕上方**爬取
- ✅ `dir_l[i] = 4` 表示该点向上生长（y减小）
- ✅ 左线顺时针、右线逆时针，但都优先选择y值更小（更高）的点
- ✅ 生长方向序列用于元素识别（十字、环岛等）

---

## 2️⃣ 原始边界点 (`points_l[][]` / `points_r[][]`)

### 坐标存储格式
```c
points_l[i][0] = x;  // 横坐标 (0~187)
points_l[i][1] = y;  // 纵坐标 (0~119)，使用图像原始坐标
```

### 索引增长方向
```
图像坐标 (imo原始)        points_l数组索引
┌────────────┐ y=0         points_l[300] ← 终点(顶部)
│            │                   ↑
│   生长路径 │                   │
│      ↑     │              (索引增大方向)
│      │     │                   │
│   起点     │             points_l[0]   ← 起点(底部)
└────────────┘ y=119
```

**关键点**：
- ✅ `points_l[0]` = 起点坐标（y≈117，底部）
- ✅ `points_l[i][1]` 随索引增大而**减小**（y值从大→小）
- ✅ 索引增大 = **向屏幕上方**移动
- ✅ 坐标值使用图像原始坐标系（y越小越靠上）

---

## 3️⃣ 提取边界数组 (`l_border[]` / `r_border[]`)

### 数组索引规则
```c
// 在 get_left() 中进行了行号反转
uint16_t row = image_h - 1 - points_l[j][1];  // 反转！
l_border[row] = col;
```

### 索引增长方向
```
l_border数组索引         对应屏幕位置
l_border[0]     ←→    屏幕顶部 (imo的y=119)
l_border[1]     ←→    ↓
l_border[2]     ←→    ↓
    ...              (向下)
l_border[118]   ←→    ↓
l_border[119]   ←→    屏幕底部 (imo的y=0)
```

### 反转对照表
| `points_l[j][1]` (原始y) | 转换后 `row` | `l_border[]` 索引 | 屏幕位置 |
|:------------------------:|:------------:|:-----------------:|:--------:|
| 0 (图像顶部)             | 119          | 119               | 底部     |
| 60 (图像中部)            | 59           | 59                | 中部     |
| 119 (图像底部)           | 0            | 0                 | 顶部     |

**关键点**：
- ✅ `l_border[0]` = 屏幕**顶部**的边界x坐标
- ✅ 索引增大 = **向屏幕下方**
- ✅ 反转的目的：让数组下标小的元素对应图像上方，符合"从下往上处理"的逻辑

---

## 4️⃣ 中线数组 (`center_line[]`)

### 索引方向
```c
center_line[i] = (l_border[i] + r_border[i]) >> 1;
```

**继承 `l_border` 的索引规则**：
- ✅ `center_line[0]` = 屏幕顶部的中线x坐标
- ✅ 索引增大 = **向屏幕下方**

---

## 5️⃣ 绘制时的坐标转换

### 当前绘制代码
```c
// 绘制原始points（完全体）
imo[row][col] = 1;  // 直接使用 points_l 的原始坐标

// 绘制中线
imo[image_h - row][center_line[row]] = 3;  // 再次反转
```

### 坐标流转全过程
```
八邻域爬取 → points_l[i][1] (y从大→小)
    ↓
提取边界  → row = 119 - y (反转)
    ↓
l_border[row] (索引从小→大 = 屏幕从上→下)
    ↓
绘制显示  → imo[119-row] (再次反转回原始坐标)
```

---

## 📊 对比总结表

| 数据结构 | 索引0位置 | 索引增大方向 | 存储坐标系 | 用途 |
|:--------:|:--------:|:----------:|:----------:|:----:|
| `dir_l[]` | 起点(底部) | ↑屏幕上方 | 方向编码 | 生长方向序列 |
| `points_l[][]` | 起点(底部) | ↑屏幕上方 | 图像原始坐标(y大→小) | 完整边界点集 |
| `l_border[]` | 屏幕顶部 | ↓屏幕下方 | 反转后坐标 | 每行的边界x值 |
| `center_line[]` | 屏幕顶部 | ↓屏幕下方 | 反转后坐标 | 每行的中线x值 |

---

## 🔧 实际应用示例

### 示例1：判断生长是否向上
```c
// dir_l[i] = 4 表示向上生长（y-1方向）
if (dir_l[i] == 4) {
    // 说明该点在向屏幕上方爬取
}
```

### 示例2：访问特定高度的边界
```c
// 要访问屏幕上方1/3处的左边界
int target_row = image_h / 3;  // l_border索引40（对应imo的y=79）
uint8_t left_x = l_border[target_row];
```

### 示例3：遍历从底到顶的边界
```c
// 使用 l_border 遍历（从顶到底）
for (int row = 0; row < image_h; row++) {
    // row=0是屏幕顶部，row=119是屏幕底部
}

// 使用 points_l 遍历（从底到顶）
for (int i = 0; i < data_stastics_l; i++) {
    // i=0是起点(底部)，i=max是终点(顶部)
    // 但 points_l[i][1] 是递减的
}
```

---

## ⚠️ 注意事项

1. **坐标系混用风险**：
   - `points_l` 使用原始图像坐标
   - `l_border` 使用反转后的索引
   - 绘制时需要注意转换关系

2. **丢线判断**：
   - `l_border[row] == border_min` 且 `left_lost[row] == 1` = 该行左线丢失
   - `r_border[row] == border_max` 且 `right_lost[row] == 1` = 该行右线丢失

3. **十字补线**：
   - `break_num` 使用的是 `points_l[i][1]`（原始y坐标）
   - 补线时操作的是 `l_border[]`（反转后索引）
   - 需要注意坐标转换

---

## 📝 版本信息

- **文件**: `image.c`
- **分支**: RE0with8neighbor
- **日期**: 2025年10月25日
- **说明**: 本文档描述八邻域边界提取算法的坐标系统设计
