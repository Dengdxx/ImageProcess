# 八邻域图像处理坐标系统说明

## 📌 一、图像坐标系统

### 1.1 基本坐标系

本项目使用**标准计算机图形学坐标系**：

```
     0   col  187
   0 ┌──────────→ x轴(列)
row  │
     │    图像区域
     ↓
     y轴(行)
   119

坐标规则：
• 原点位置: 左上角 (0, 0)
• x轴方向: 向右为正 (col: 0→187)
• y轴方向: 向下为正 (row: 0→119) ⚠️
• 图像尺寸: 188×120 像素
```

### 1.2 算法起点

八邻域边界追踪从**图像底部**开始：

```
起始行: y ≈ 117 (接近图像底部)
起始列: x ≈ 94  (图像中央)
生长方向: 主要向上 (y值减小)
```


## 📐 二、方向编码系统

### 2.1 核心概念

边界追踪使用**八邻域方向编码**（0-7共8个方向）。

⚠️ **关键发现：记录值与实际生长方向存在+1偏移**

### 2.2 seeds数组定义

#### 左线 seeds_l[8][2] (顺时针扫描)

```c
static int8_t seeds_l[8][2] = { 
    {0,  1},   // [0] 向下
    {-1, 1},   // [1] 左下
    {-1, 0},   // [2] 向左
    {-1,-1},   // [3] 左上
    {0, -1},   // [4] 向上   ← 主要生长方向
    {1, -1},   // [5] 右上
    {1,  0},   // [6] 向右
    {1,  1}    // [7] 右下
};
```

#### 右线 seeds_r[8][2] (逆时针扫描)

```c
static int8_t seeds_r[8][2] = { 
    {0,  1},   // [0] 向下
    {1,  1},   // [1] 右下
    {1,  0},   // [2] 向右
    {1, -1},   // [3] 右上
    {0, -1},   // [4] 向上   ← 主要生长方向
    {-1,-1},   // [5] 左上
    {-1, 0},   // [6] 向左
    {-1, 1}    // [7] 左下
};
```

### 2.3 方向编码图示

#### 左线方向图（顺时针）

```
        3      4      5
      左上    向上    右上
        ╲      ↑      ╱
         ╲     │     ╱
   2 ←────●─────────→ 6
  向左     │         向右
         ╱ │ ╲
        ╱  │  ╲
       ╱   ↓   ╲
      1    0    7
    左下  向下  右下
```

#### 右线方向图（逆时针）

```
        5      4      3
      左上    向上    右上
        ╲      ↑      ╱
         ╲     │     ╱
   6 ←────●─────────→ 2
  向左     │         向右
         ╱ │ ╲
        ╱  │  ╲
       ╱   ↓   ╲
      7    0    1
    左下  向下  右下
```

### 2.4 +1偏移的原理

#### 边界检测逻辑

代码在检测边界时使用以下逻辑：

```c
for (i = 0; i < 8; i++) {
    if (image[i位置] == 0 && image[i+1位置] == 255) {
        // 发现黑白边界
        选择坐标 = i+1位置的坐标;  // ✓ 实际移动到i+1
        记录方向 = i;               // ✗ 但记录的是i
    }
}
```

#### 为什么存在偏移？

1. **检测的是边界**：`i位置是黑` + `i+1位置是白` = 找到黑白交界
2. **选择白色点**：算法选择白色区域（道路）的点，所以用`i+1`
3. **记录黑色方向**：但为了标识"在哪里发现边界"，记录的是`i`

#### 实际效果

```
记录值 dir_l[x] = i  →  实际移动方向 = seeds_l[i+1]
```

**示例：记录值3的含义**

```
记录值 = 3
↓
在seeds_l[3]方向检测到黑色 (左上方向)
↓
实际选择seeds_l[4]位置的白色点 (向上方向)
↓
结果：记录3 = 实际向上生长 ✓
```

### 2.5 方向映射对照表

#### 左线方向映射

| 记录值 | 检测方向 | 实际生长 | 坐标偏移 | 常见度 |
|:-----:|:-------:|:-------:|:--------:|:------:|
| 0 | 向下 | 左下 | {-1, 1} | 罕见 |
| 1 | 左下 | 向左 | {-1, 0} | 较少 |
| 2 | 向左 | 左上 | {-1,-1} | 左弯 |
| **3** | **左上** | **向上** | **{0,-1}** | **最常见** |
| **4** | **向上** | **右上** | **{1,-1}** | **很常见** |
| **5** | **右上** | **向右** | **{1, 0}** | **右弯** |
| 6 | 向右 | 右下 | {1, 1} | 较少 |
| 7 | 右下 | 向下 | {0, 1} | 异常 |

#### 右线方向映射

| 记录值 | 检测方向 | 实际生长 | 坐标偏移 | 常见度 |
|:-----:|:-------:|:-------:|:--------:|:------:|
| 0 | 向下 | 右下 | {1, 1} | 罕见 |
| 1 | 右下 | 向右 | {1, 0} | 较少 |
| 2 | 向右 | 右上 | {1,-1} | 右弯 |
| **3** | **右上** | **向上** | **{0,-1}** | **最常见** |
| **4** | **向上** | **左上** | **{-1,-1}** | **很常见** |
| **5** | **左上** | **向左** | **{-1, 0}** | **左弯** |
| 6 | 向左 | 左下 | {-1, 1} | 较少 |
| 7 | 左下 | 向下 | {0, 1} | 异常 |

### 2.6 典型模式识别

#### 正常爬升 (最常见)

```
dir_l[] = [3, 3, 3, 3, ...]
→ 实际：向上 → 向上 → 向上 → ...
→ 含义：垂直向图像顶部爬取
```

#### 斜向爬升 (常见)

```
dir_l[] = [4, 4, 4, 4, ...]
→ 实际：右上 → 右上 → 右上 → ...
→ 含义：沿斜线向右上方爬取
```

#### 锯齿爬升 (弯道)

```
dir_l[] = [3, 4, 3, 4, 3, 4, ...]
→ 实际：向上 → 右上 → 向上 → 右上 → ...
→ 含义：轻微右转弯
```

#### 水平延伸 (顶部区域)

```
dir_l[] = [5, 5, 5, 5, ...]
→ 实际：向右 → 向右 → 向右 → ...
→ 含义：沿水平方向延伸
```

### 2.7 实际案例分析

以下是真实测试图像的dir_l数组：

```
阶段1: [3,3,3,3,3,3,3,3,...]
→ 起点垂直向上爬取

阶段2: [4,4,4,4,4,4,4,4,4,4,4,5,4,4,4,4,...]
→ 右上为主，偶尔向右

阶段3: [4,5,4,5,4,5,4,5,...]
→ 右上与向右快速交替 = 锯齿状右上爬升

阶段4: [5,5,5,5,5,5,...]
→ 持续向右 = 到达顶部水平延伸

阶段5: [2,2,1,1,1,...]
→ 左上→向左 = 左转

阶段6: [7,0,1,...]
→ 向下→左下→向左 = 异常状态(已到顶部)
```

完全符合从底部向上、向右上、到顶部左转的图像特征！✓

---

## 📊 三、数据结构说明

### 3.1 dir_l[] / dir_r[] (方向数组)

**用途**: 记录边界追踪过程中每个点的生长方向

```c
uint8_t dir_l[IMAGE_H];  // 左线方向数组
uint8_t dir_r[IMAGE_H];  // 右线方向数组
```

**索引规则**:
- `dir_l[0]` = 起点(图像底部, y≈117)的方向
- `dir_l[i]` = 第i个追踪点的方向  
- 索引增大 = 向图像顶部移动

**数值含义**:
- 存储值0-7，对应seeds数组的索引
- ⚠️ 注意：记录值 ≠ 实际生长方向（存在+1偏移）
- 实际方向 = `seeds[(dir_l[i] + 1) & 7]`

### 3.2 points_l[][] / points_r[][] (边界点坐标)

**用途**: 存储边界追踪路径上每个点的完整坐标

```c
uint16_t points_l[IMAGE_H][2];  // [索引][x/y]
uint16_t points_r[IMAGE_H][2];
```

**存储格式**:
```c
points_l[i][0] = x坐标 (0-187)
points_l[i][1] = y坐标 (0-119)
```

**索引规则**:
- `points_l[0]` = 起点坐标 (x≈94, y≈117)
- 索引增大 = y值减小 (向图像顶部)
- 坐标使用原始图像坐标系

### 3.3 l_border[] / r_border[] (边界数组)

**用途**: 存储每一行的边界x坐标（经过行号反转）

```c
uint8_t l_border[IMAGE_H];  // 左边界
uint8_t r_border[IMAGE_H];  // 右边界
```

**生成方式**:
```c
uint16_t row = image_h - 1 - points_l[j][1];  // ⚠️ 行号反转
l_border[row] = points_l[j][0];
```

**索引规则**:
- `l_border[0]` = 图像顶部(y=0)的左边界x值
- `l_border[119]` = 图像底部(y=119)的左边界x值
- 索引增大 = 向图像底部移动
- ⚠️ 与points_l索引方向**相反**

### 3.4 center_line[] (中线数组)

**用途**: 存储每一行的中线x坐标

```c
uint8_t center_line[IMAGE_H];
```

**计算方式**:
```c
center_line[i] = (l_border[i] + r_border[i]) >> 1;
```

**索引规则**: 继承l_border的规则
- `center_line[0]` = 图像顶部中线
- 索引增大 = 向图像底部

### 3.5 数据结构对比表

| 数组名 | 索引0位置 | 索引增长 | 坐标系 | 主要用途 |
|:------:|:--------:|:-------:|:------:|:-------:|
| `dir_l[]` | 底部 | ↑向上 | 方向值0-7 | 路径识别 |
| `points_l[][]` | 底部 | ↑向上 | 原始坐标 | 完整路径 |
| `l_border[]` | **顶部** | **↓向下** | **反转坐标** | 逐行边界 |
| `center_line[]` | **顶部** | **↓向下** | **反转坐标** | 控制决策 |

---

## 🔄 四、坐标转换流程

### 4.1 追踪阶段 (points → dir)

**从图像底部开始向上追踪边界**

```
步骤1: 初始化起点
  起点位置: (x≈94, y≈117)
  存储到: points_l[0] = {94, 117}
  
步骤2: 八邻域扫描
  以当前点为中心，按seeds顺序扫描8个邻域
  
步骤3: 检测边界
  if (当前方向i是黑 && 下一方向i+1是白)
    → 找到边界！
    
步骤4: 记录数据
  points_l[索引] = i+1位置的坐标  ← 实际移动到白色点
  dir_l[索引] = i                 ← 记录黑色方向
  
步骤5: 重复
  以新点为中心，继续扫描，直到到达图像顶部
```

**结果示例**:
```
points_l[0] = {94, 117}  dir_l[0] = 3  ← 起点,向上
points_l[1] = {94, 116}  dir_l[1] = 3  ← 继续向上
points_l[2] = {94, 115}  dir_l[2] = 3  ← 继续向上
points_l[3] = {95, 114}  dir_l[3] = 4  ← 右上
...
```

### 4.2 提取阶段 (points → border)

**将追踪路径转换为逐行边界数组**

```
输入: points_l[][] (追踪路径，索引0在底部)
输出: l_border[]   (逐行边界，索引0在顶部)
```

**转换过程**:

```c
// 遍历所有追踪点
for (j = 0; j < l_data_statics; j++) {
    
    col = points_l[j][0];        // 获取x坐标
    y_original = points_l[j][1]; // 获取原始y坐标
    
    // ⚠️ 关键: 行号反转
    row = (image_h - 1) - y_original;
    //    119 - y_original
    
    // 存储到border数组
    l_border[row] = col;
}
```

**转换示例**:

```
points_l[0] = {94, 117}  →  row = 119-117 = 2   →  l_border[2] = 94
points_l[1] = {94, 116}  →  row = 119-116 = 3   →  l_border[3] = 94
points_l[2] = {94, 115}  →  row = 119-115 = 4   →  l_border[4] = 94
points_l[3] = {95, 5}    →  row = 119-5 = 114   →  l_border[114] = 95
...
```

**为什么要反转?**
- points数组: 符合追踪逻辑(从下往上)
- border数组: 符合处理逻辑(按行号访问)
- 反转后: `l_border[行号]` 直接得到该行的边界

### 4.3 计算阶段 (border → center_line)

**计算中线**

```c
for (i = 0; i < image_h; i++) {
    center_line[i] = (l_border[i] + r_border[i]) >> 1;
}
```

**示例**:
```
行号  左边界      右边界       中线
0     l_border[0]=20   r_border[0]=180   center_line[0]=100  顶部
1     l_border[1]=22   r_border[1]=178   center_line[1]=100
...
119   l_border[119]=90 r_border[119]=98  center_line[119]=94 底部
```

### 4.4 绘制阶段 (所有数据 → 图像)

**绘制追踪路径**:
```c
// 直接使用原始坐标，无需转换
imo[points_l[i][1]][points_l[i][0]] = 1;
```

**绘制边界/中线**:
```c
// 需要再次反转回原始坐标
for (row = 0; row < image_h; row++) {
    imo[image_h - 1 - row][l_border[row]] = 2;      // 左边界
    imo[image_h - 1 - row][r_border[row]] = 2;      // 右边界
    imo[image_h - 1 - row][center_line[row]] = 3;   // 中线
}
```

**为什么再次反转?**
- border数组的row: 0=图像顶部
- imo数组的row: 0=图像顶部
- 但含义不同，需要转换

---

## 💡 五、快速参考

### 5.1 记忆口诀

```
points和dir: 从底向上，索引递增
border和line: 从顶向下，按行访问
记录方向i: 在i处发现黑
实际移动: 向i+1白色去
```

### 5.2 常见操作速查

#### 判断某点是否向上生长
```c
if (dir_l[i] == 3) {
    // 记录3 → 实际向上(主要方向)
}
```

#### 获取某行的边界
```c
// 获取图像第60行(从0计数)的边界
uint8_t left = l_border[60];
uint8_t right = r_border[60];
```

#### 转换实际生长方向
```c
uint8_t recorded = dir_l[i];
uint8_t actual = (recorded + 1) & 7;
int8_t dx = seeds_l[actual][0];
int8_t dy = seeds_l[actual][1];
```

#### 检测弯道
```c
// 左弯: 记录2(左上) 或 1(向左)
// 右弯: 记录4(右上) 或 5(向右)
bool is_left_curve = (dir_l[i] == 2 || dir_l[i] == 1);
bool is_right_curve = (dir_l[i] == 4 || dir_l[i] == 5);
```

### 5.3 调试检查清单

**追踪阶段**:
- ✓ 起点在图像底部? (y ≈ 117)
- ✓ dir_l[0]通常是3? (向上)
- ✓ points_l的y值递减? (从大到小)

**边界阶段**:
- ✓ l_border[0]对应图像顶部?
- ✓ 左右边界没有交叉? (l_border < r_border)
- ✓ 丢失行标记正确? (lost数组)

**绘制阶段**:
- ✓ 坐标转换正确?
- ✓ 边界在图像内? (0-187, 0-119)
- ✓ 颜色编码清晰? (1=边界点, 2=边界线, 3=中线)

---

## 📖 六、典型场景示例

### 6.1 直道识别

**特征**: 左右边界都是垂直向上

```
dir_l[] = [3, 3, 3, 3, 3, ...]
dir_r[] = [3, 3, 3, 3, 3, ...]

实际含义:
  两侧都持续向上 → 直道
```

**图像示意**:
```
      |         |
      |         |
      |  道路   |
      |         |
      |         |
     起点
```

### 6.2 右弯道识别

**特征**: 左线向右上，右线向右

```
dir_l[] = [3, 3, 4, 4, 5, 5, ...]
         向上→右上→向右
         
dir_r[] = [3, 3, 3, 2, 2, 1, ...]
         向上→向上→右上→向右

实际含义:
  左线右移快于右线 → 右弯
```

**图像示意**:
```
           ╱
          ╱
         │
        │
       │
      起点
```

### 6.3 左弯道识别

**特征**: 右线向左上，左线向左

```
dir_l[] = [3, 3, 3, 2, 2, 1, ...]
         向上→左上→向左
         
dir_r[] = [3, 3, 4, 4, 5, 5, ...]
         向上→左上→向左

实际含义:
  右线左移快于左线 → 左弯
```

**图像示意**:
```
    ╲
     ╲
      │
       │
        │
       起点
```

### 6.4 十字路口识别

**特征**: 先向上后向下

```
dir_l[] = [..., 3, 3, 4, 6, 6, 7, 0, ...]
              向上→右上→右下→向下→左下
              
关键序列: [4, 6, 6] 或 [4, 4, 4, 6, 6, 6]
  右上→右下 = 到达顶部后向下
```

**图像示意**:
```
  ────┬────
      │
      │
      │
     起点
```

### 6.5 环岛识别

**特征**: 一侧持续弯曲

```
左环岛 (左线大幅左转):
dir_l[] = [3, 3, 2, 2, 1, 1, 1, 1, 0, 7, ...]
         向上→左上→向左→左下→向下

右环岛 (右线大幅右转):
dir_r[] = [3, 3, 2, 2, 1, 1, 1, 1, 0, 7, ...]
         向上→右上→向右→右下→向下
```

**图像示意**:
```
左环岛:              右环岛:
    ╭─╮                ╭─╮
    │ │                │ │
    ╰─┤                ├─╯
      │                │
```

### 6.6 异常情况

**边界丢失**:
```c
if (l_border[row] == 0 && left_lost[row] == 1) {
    // 该行左边界丢失
    // 需要补线
}
```

**边界交叉** (算法错误):
```c
if (l_border[row] >= r_border[row]) {
    // 左右边界交叉，数据异常
    // 需要检查追踪逻辑
}
```

**顶部到达**:
```c
if (points_l[i][1] < 5) {
    // y坐标小于5，接近图像顶部
    // 可能需要停止追踪
}
```

---

## ⚠️ 七、注意事项

### 7.1 坐标系陷阱

**❌ 常见错误**: 混淆不同数组的索引含义

```c
// 错误: 认为dir_l[0]是顶部
if (dir_l[0] == 7) { ... }  // 错！0是底部

// 正确: dir_l[0]是起点(底部)
if (dir_l[l_data_statics-1] == 7) { ... }  // 对！最后一个点
```

**❌ 常见错误**: 忘记行号反转

```c
// 错误: 直接用points的y作为border索引
l_border[points_l[i][1]] = points_l[i][0];  // 错！

// 正确: 需要反转
uint16_t row = image_h - 1 - points_l[i][1];
l_border[row] = points_l[i][0];  // 对！
```

### 7.2 方向编码陷阱

**❌ 常见错误**: 直接用记录值判断实际方向

```c
// 错误: 认为记录3是左上
if (dir_l[i] == 3) {
    // 误以为向左上移动
}

// 正确: 记录3实际是向上
if (dir_l[i] == 3) {
    // 实际向上移动 seeds_l[4] = {0, -1}
}
```

**✓ 正确做法**: 使用+1偏移

```c
uint8_t actual_dir = (dir_l[i] + 1) & 7;
int8_t dx = seeds_l[actual_dir][0];
int8_t dy = seeds_l[actual_dir][1];
```

### 7.3 边界数组陷阱

**❌ 常见错误**: 遍历方向错误

```c
// 如果想从底部到顶部遍历border
for (int row = 0; row < image_h; row++) {
    // 错！这是从顶部到底部
}

// 正确: 从底部到顶部
for (int row = image_h-1; row >= 0; row--) {
    // 对！row减小 = 从底向顶
}
```

### 7.4 调试建议

**打印关键信息**:
```c
printf("起点: points_l[0] = {%d, %d}\n", 
       points_l[0][0], points_l[0][1]);
printf("终点: points_l[%d] = {%d, %d}\n",
       l_data_statics-1,
       points_l[l_data_statics-1][0],
       points_l[l_data_statics-1][1]);
printf("起点方向: dir_l[0] = %d (实际=%d)\n",
       dir_l[0], (dir_l[0]+1)&7);
```

**可视化验证**:
```c
// 在图像上用不同颜色标记
imo[y][x] = 1;  // 白色: 追踪路径
imo[y][x] = 2;  // 红色: 左右边界
imo[y][x] = 3;  // 绿色: 中线
imo[y][x] = 4;  // 蓝色: 补线区域
```

---

## 📚 八、附录

### 8.1 完整代码流程

```c
// ========== 阶段1: 初始化 ==========
get_start_point(image_h - 3);  // 从底部开始
points_l[0] = {start_x, start_y};  // 通常 {94, 117}

// ========== 阶段2: 八邻域追踪 ==========
for (追踪循环) {
    // 计算8个邻域坐标
    for (i = 0; i < 8; i++) {
        search_filds_l[i][0] = center_x + seeds_l[i][0];
        search_filds_l[i][1] = center_y + seeds_l[i][1];
    }
    
    // 扫描边界
    for (i = 0; i < 8; i++) {
        if (image[search_i] == 黑 && image[search_i+1] == 白) {
            // 找到边界
            temp_points[j] = search_filds_l[(i+1)&7];  // 选i+1
            dir_l[索引] = i;  // 记录i
        }
    }
    
    // 优先选择y小的点(向上)
    for (j = 0; j < 候选数; j++) {
        if (temp_points[j][1] < center_y) {
            center = temp_points[j];  // 更新中心点
        }
    }
    
    points_l[索引] = center;  // 保存新点
}

// ========== 阶段3: 提取边界 ==========
for (j = 0; j < l_data_statics; j++) {
    col = points_l[j][0];
    y = points_l[j][1];
    row = (image_h - 1) - y;  // ⚠️ 反转
    l_border[row] = col;
}

// ========== 阶段4: 计算中线 ==========
for (i = 0; i < image_h; i++) {
    center_line[i] = (l_border[i] + r_border[i]) >> 1;
}

// ========== 阶段5: 绘制显示 ==========
// 绘制追踪路径
for (i = 0; i < l_data_statics; i++) {
    imo[points_l[i][1]][points_l[i][0]] = 1;
}

// 绘制边界和中线
for (row = 0; row < image_h; row++) {
    imo[image_h-1-row][l_border[row]] = 2;
    imo[image_h-1-row][center_line[row]] = 3;
}
```

### 8.2 关键宏定义

```c
#define IMAGE_W 188      // 图像宽度
#define IMAGE_H 120      // 图像高度
#define BORDER_MIN 0     // 左边界最小值
#define BORDER_MAX 187   // 右边界最大值
```

### 8.3 相关文件

```
src/image.c          - 核心算法实现
src/image.h          - 接口定义
src/processor.c      - 图像处理主流程
data/                - 测试图像数据
```

### 8.4 常用调试宏

```c
#define DEBUG_PRINT_POINTS 1   // 打印追踪点
#define DEBUG_PRINT_DIR 1      // 打印方向数组
#define DEBUG_DRAW_PATH 1      // 绘制追踪路径
```

---

## 🎯 九、核心要点总结

### 9.1 三大坐标系

1. **图像坐标系**: y轴向下为正
2. **追踪坐标系**: 从底向上，索引递增
3. **边界坐标系**: 从顶向下，行号递增

### 9.2 关键发现

**+1偏移规律**:
```
记录值 i  →  实际方向 seeds[i+1]
这是算法的核心特征，不是bug！
```

**原因**: 
- 检测: "i是黑 且 i+1是白" 
- 选择: i+1的白色点
- 记录: i的黑色方向

### 9.3 最常见方向

| 记录值 | 实际方向 | 使用场景 |
|:-----:|:-------:|:-------:|
| **3** | **向上** | **主要爬升方向** |
| **4** | **右上/左上** | **弯道** |
| **5** | **向右/向左** | **水平延伸** |

### 9.4 数组索引规则

```
dir_l[0]      ↔  图像底部起点
points_l[0]   ↔  图像底部起点
l_border[0]   ↔  图像顶部 (⚠️注意反转)
center_line[0] ↔  图像顶部
```

### 9.5 转换公式

**追踪到边界**:
```c
row = (IMAGE_H - 1) - points_l[i][1]
l_border[row] = points_l[i][0]
```

**边界到绘制**:
```c
display_row = (IMAGE_H - 1) - row
imo[display_row][l_border[row]] = color
```

**记录到实际**:
```c
actual_direction = (dir_l[i] + 1) & 7
actual_offset = seeds_l[actual_direction]
```

---

## ✅ 十、验证检查表

使用本文档时，请确认以下理解：

- [ ] 理解y轴向下为正
- [ ] 理解追踪从底部开始
- [ ] 理解+1偏移的原因
- [ ] 理解记录3=实际向上
- [ ] 理解points和border索引相反
- [ ] 理解行号反转的必要性
- [ ] 能正确转换坐标
- [ ] 能识别常见路径模式
- [ ] 知道如何调试坐标问题
- [ ] 能避免常见陷阱

---

## 📝 文档信息

**版本**: v2.0  
**日期**: 2025年10月25日  
**作者**: 基于RE0with8neighbor分支  
**状态**: 已验证并优化

**主要改进**:
- ✅ 发现并验证+1偏移规律
- ✅ 重构文档结构，层次清晰
- ✅ 添加大量可视化图示
- ✅ 提供实际案例分析
- ✅ 增加快速参考和速查表
- ✅ 完善调试和注意事项

**适用场景**:
- 理解八邻域边界追踪算法
- 调试坐标转换问题
- 实现路径识别功能
- 新成员快速上手

---

**📌 如有疑问，请参考本文档对应章节，或查看源代码注释**


```
┌────────────────── 记录方向（检测到黑色） ──────────────────┐
│                                                              │
│            3(左上)   4(向上)   5(右上)                       │
│               ╲        ↑        ╱                           │
│                ╲       │       ╱                            │
│                 ╲      │      ╱                             │
│    2(向左) ←─────●─────────→ 6(向右)  当前点               │
│                 ╱      │      ╲                             │
│                ╱       │       ╲                            │
│               ╱        ↓        ╲                           │
│            1(左下)   0(向下)   7(右下)                       │
│                                                              │
└──────────────────────────────────────────────────────────────┘

┌────────────────── 实际生长方向（+1偏移） ──────────────────┐
│                                                              │
│            2(左上)   3(向上)   4(右上)                       │
│               ╲        ↑        ╱                           │
│                ╲       │       ╱                            │
│                 ╲      │      ╱                             │
│    1(向左) ←─────●─────────→ 5(向右)  当前点               │
│                 ╱      │      ╲                             │
│                ╱       │       ╲                            │
│               ╱        ↓        ╲                           │
│            0(左下)   7(向下)   6(右下)                       │
│                                                              │
│  实际生长 = seeds_l[(记录值+1) & 7]                          │
└──────────────────────────────────────────────────────────────┘

seeds_l数组定义（顺时针）:
  索引0:{0,1}   索引1:{-1,1}  索引2:{-1,0}  索引3:{-1,-1}
  索引4:{0,-1}  索引5:{1,-1}  索引6:{1,0}   索引7:{1,1}

常用记录值含义：
  • 记录3 → 检测到左上黑色 → 实际向上(4)生长 ← 主要爬升方向
  • 记录4 → 检测到向上黑色 → 实际右上(5)生长
  • 记录5 → 检测到右上黑色 → 实际向右(6)生长
  • 记录2 → 检测到向左黑色 → 实际左上(3)生长
```

#### **右线（逆时针扫描）完整图示**

```
┌────────────────── 记录方向（检测到黑色） ──────────────────┐
│                                                              │
│            5(左上)   4(向上)   3(右上)                       │
│               ╲        ↑        ╱                           │
│                ╲       │       ╱                            │
│                 ╲      │      ╱                             │
│    6(向左) ←─────●─────────→ 2(向右)  当前点               │
│                 ╱      │      ╲                             │
│                ╱       │       ╲                            │
│               ╱        ↓        ╲                           │
│            7(左下)   0(向下)   1(右下)                       │
│                                                              │
└──────────────────────────────────────────────────────────────┘

┌────────────────── 实际生长方向（+1偏移） ──────────────────┐
│                                                              │
│            4(左上)   3(向上)   2(右上)                       │
│               ╲        ↑        ╱                           │
│                ╲       │       ╱                            │
│                 ╲      │      ╱                             │
│    5(向左) ←─────●─────────→ 1(向右)  当前点               │
│                 ╱      │      ╲                             │
│                ╱       │       ╲                            │
│               ╱        ↓        ╲                           │
│            6(左下)   7(向下)   0(右下)                       │
│                                                              │
│  实际生长 = seeds_r[(记录值+1) & 7]                          │
└──────────────────────────────────────────────────────────────┘

seeds_r数组定义（逆时针）:
  索引0:{0,1}   索引1:{1,1}   索引2:{1,0}   索引3:{1,-1}
  索引4:{0,-1}  索引5:{-1,-1} 索引6:{-1,0}  索引7:{-1,1}

常用记录值含义：
  • 记录3 → 检测到右上黑色 → 实际向上(4)生长 ← 主要爬升方向
  • 记录4 → 检测到向上黑色 → 实际左上(5)生长
  • 记录5 → 检测到左上黑色 → 实际向左(6)生长
  • 记录2 → 检测到向右黑色 → 实际右上(3)生长
```

#### **左右对比简化版**

**⚠️ 注意：下图标注的是"实际生长方向"，即 seeds[(记录值+1) & 7]**

```
┌─────────── 左线(顺时针) ───────────┐    ┌─────────── 右线(逆时针) ───────────┐
│                                     │    │                                     │
│   记录2  记录3  记录4               │    │   记录4  记录3  记录2               │
│   实际:  实际:  实际:               │    │   实际:  实际:  实际:               │
│   左上   向上   右上                │    │   左上   向上   右上                │
│    ╲      ↑      ╱                 │    │    ╲      ↑      ╱                 │
│     ╲     │     ╱                  │    │     ╲     │     ╱                  │
│      ╲    │    ╱                   │    │      ╲    │    ╱                   │
│ 记录1 ←── ● ──→ 记录5              │    │ 记录5 ←── ● ──→ 记录1              │
│ 实际:      │      实际:             │    │ 实际:      │      实际:             │
│ 向左              向右              │    │ 向左              向右              │
│      ╱    │    ╲                   │    │      ╱    │    ╲                   │
│     ╱     │     ╲                  │    │     ╱     │     ╲                  │
│    ╱      ↓      ╲                 │    │    ╱      ↓      ╲                 │
│   左下    向下    右下              │    │   左下    向下    右下              │
│   实际:  实际:  实际:               │    │   实际:  实际:  实际:               │
│   记录0  记录7  记录6               │    │   记录6  记录7  记录0               │
│                                     │    │                                     │
│  seeds定义顺序:                     │    │  seeds定义顺序:                     │
│  0:{0,1}   1:{-1,1}  2:{-1,0}      │    │  0:{0,1}   1:{1,1}   2:{1,0}       │
│  3:{-1,-1} 4:{0,-1}  5:{1,-1}      │    │  3:{1,-1}  4:{0,-1}  5:{-1,-1}     │
│  6:{1,0}   7:{1,1}                 │    │  6:{-1,0}  7:{-1,1}                │
│                                     │    │                                     │
│  记录与实际的关系:                  │    │  记录与实际的关系:                  │
│  实际方向 = seeds_l[(记录值+1)&7]   │    │  实际方向 = seeds_r[(记录值+1)&7]   │
│                                     │    │                                     │
│  常用方向解释:                      │    │  常用方向解释:                      │
│  • 记录3 → 实际向上(主方向)         │    │  • 记录3 → 实际向上(主方向)         │
│  • 记录4 → 实际右上                 │    │  • 记录4 → 实际左上                 │
│  • 记录5 → 实际向右                 │    │  • 记录5 → 实际向左                 │
│  • y轴：向下为正(标准图形学坐标)    │    │  • y轴：向下为正(标准图形学坐标)    │
│  • 算法优先选择y值小的点(向上)      │    │  • 算法优先选择y值小的点(向上)      │
│                                     │    │                                     │
└─────────────────────────────────────┘    └─────────────────────────────────────┘
```

### 代码实现细节

```c
// 1. seeds定义（来自image.c第167行）
static int8_t seeds_l[8][2] = { 
    {0,  1},   // 索引0: 向下 {x+0, y+1}
    {-1, 1},   // 索引1: 左下 {x-1, y+1}
    {-1, 0},   // 索引2: 向左 {x-1, y+0}
    {-1,-1},   // 索引3: 左上 {x-1, y-1}
    {0, -1},   // 索引4: 向上 {x+0, y-1} ← 主要生长方向
    {1, -1},   // 索引5: 右上 {x+1, y-1}
    {1,  0},   // 索引6: 向右 {x+1, y+0}
    {1,  1}    // 索引7: 右下 {x+1, y+1}
};

// 2. 使用seeds计算邻域（第202行）
search_filds_l[i][0] = center_point_l[0] + seeds_l[i][0]; //x
search_filds_l[i][1] = center_point_l[1] + seeds_l[i][1]; //y

// 3. 边界检测与方向记录（第227-236行）⚠️ 关键逻辑
for (i = 0; i < 8; i++) {
    if (image[search_filds_l[i][1]][search_filds_l[i][0]] == 0          // i位置是黑
        && image[search_filds_l[(i + 1) & 7][1]][search_filds_l[(i + 1) & 7][0]] == 255) // i+1位置是白
    {
        temp_l[index_l][0] = search_filds_l[(i + 1) & 7][0];  // 实际选择 i+1 的坐标
        temp_l[index_l][1] = search_filds_l[(i + 1) & 7][1];
        index_l++;
        dir_l[l_data_statics - 1] = (i);  // ⚠️ 但记录的是 i，不是 i+1
    }
}

// 4. 决策逻辑（第247行）
for (j = 0; j < index_l; j++) {
    if (center_point_l[1] > temp_l[j][1]) { // 优先选择y值小的点（向上）
        center_point_l[0] = temp_l[j][0];
        center_point_l[1] = temp_l[j][1];
    }
}

// 解释方向记录的偏移：
// - 检测条件：当前i是黑，下一个i+1是白 → 找到了"黑白边界"
// - 边界含义：从i(黑)到i+1(白)的过渡位置
// - 实际选择：将i+1(白色区域)作为新的边界点
// - 记录方向：记录i，表示"在i方向检测到边界"
// - 实际生长：向i+1方向移动
// 
// 因此：dir_l[x] = i 表示"在seeds_l[i]方向发现边界"
//       实际生长方向是 seeds_l[(i+1) & 7]
```

### 左右线生长规律

#### **左线（顺时针）特征**
```
正常向上爬取时的典型序列：
记录: 3→3→3→3→4→3→3→...
实际: 向上→向上→向上→右上→向上→...

遇到左弯道时：
记录: 3→2→2→1→1→...
实际: 向上→左上→左上→向左→向左→...

遇到右弯道时：
记录: 3→4→4→5→5→...
实际: 向上→右上→右上→向右→向右→...

到达顶部异常（开始向下）：
记录: 2→1→0→7→...
实际: 左上→向左→左下→向下→右下→...

顶部拐角调整：
记录: 6→7→0→... 或 4→5→5→...
实际: 右下→向下→左下→... 或 右上→向右→向右→...
```

#### **右线（逆时针）特征**
```
正常向上爬取时的典型序列：
记录: 3→3→3→3→4→3→3→...
实际: 向上→向上→向上→左上→向上→...

遇到右弯道时：
记录: 3→2→2→1→1→...
实际: 向上→右上→右上→向右→向右→...

遇到左弯道时：
记录: 3→4→4→5→5→...
实际: 向上→左上→左上→向左→向左→...

开始向下时（异常）：
记录: 6→7→0→0→...
实际: 右下→向下→左下→左下→...
```

### 生长方向判断准则

#### **正常向上生长**
- `dir_l[i] = 3`：左线实际**向上** (seeds_l[4] = {0,-1})
- `dir_l[i] = 4`：左线实际**右上** (seeds_l[5] = {1,-1})
- `dir_r[i] = 3`：右线实际**向上** (seeds_r[4] = {0,-1})
- `dir_r[i] = 4`：右线实际**左上** (seeds_r[5] = {-1,-1})

#### **弯道识别**
```c
// 左弯道特征（连续向左生长）
// 左线记录: 2,2,2 或 1,1,1
// 实际生长: 左上→向左 或 向左→左下

// 右弯道特征（连续向右生长）
// 左线记录: 4,4,4 或 5,5,5
// 实际生长: 右上→向右 或 向右→右下

// 十字路口特征 (arr.up_inner = {4,4,4,6,6,6})
// 左右两边记录都是: 4,4,4,6,6,6
// 实际生长: 右上→右上→右上→右下→右下→右下（向上后开始向下）
```

#### **异常状态检测**
```c
// 左线开始向下（代码第267行检测）
if (dir_l[l_data_statics - 1] == 7 
    && points_r[r_data_statics][1] > points_l[l_data_statics - 1][1]) {
    // 记录7 → 实际向下(seeds_l[0] = {0,1})
    // 且左线比右线高 → 等待右边
}

// 向下生长的记录值 (7,0,1) 对应实际方向 (向下,左下,向左)
// 通常表示：
// - 十字路口上半部分
// - 环岛入口
// - 边界丢失后的错误生长
```

### 索引增长方向
```
屏幕位置          dir_l数组          points_l数组
┌───────┐ y=0    dir_l[最大]      points_l[最大]  ← 终点(顶部)
│       │          ↑                  ↑
│       │      (索引增大)         (索引增大)
│       │          ↑                  ↑
│  道路  │          ↑                  ↑
│       │          ↑                  ↑
└───────┘ y=119  dir_l[0]         points_l[0]     ← 起点(底部)

时间顺序：从屏幕底部往上爬取
```

**关键点**：
- ✅ `dir_l[0]` = **起点（屏幕底端，y≈117）**的生长方向
- ✅ 索引增大 = 时间推进 = **向屏幕上方**爬取
- ✅ `dir_l[i] = 4` 表示该点向上生长（y减小）
- ✅ 左线顺时针、右线逆时针，但都优先选择y值更小（更高）的点
- ✅ 生长方向序列用于元素识别（十字、环岛等）

**起点确认**：
```c
// 代码中的起点搜索
get_start_point(image_h - 3)  // image_h = 120
start_row = 117 (或 115, 113) // 接近图像底部
start_point_l[1] = start_row  // y坐标≈117

// 因此
dir_l[0]     → 对应屏幕底端 (y≈117)
dir_l[最大]  → 对应屏幕顶端 (y≈0)
```

---

## 2️⃣ 原始边界点 (`points_l[][]` / `points_r[][]`)

### 坐标存储格式
```c
points_l[i][0] = x;  // 横坐标 (0~187)
points_l[i][1] = y;  // 纵坐标 (0~119)，使用图像原始坐标
```

### 索引增长方向
```
屏幕位置          points_l数组
┌───────┐ y=0    points_l[最大] ← 终点(顶部，y值最小)
│       │              ↑
│       │          (索引增大)
│       │              ↑
│  道路  │              ↑
│       │              ↑
└───────┘ y=119  points_l[0]   ← 起点(底部，y值最大)
```

**关键点**：
- ✅ `points_l[0]` = **起点坐标（屏幕底端，y≈117）**
- ✅ `points_l[i][1]` 随索引增大而**减小**（y值从大→小，从下→上）
- ✅ 索引增大 = **向屏幕上方**移动
- ✅ 坐标值使用图像原始坐标系（y越小越靠上）

**实例验证**：
```
假设 image_h = 120
points_l[0]   = [x0, 117]  ← 起点，屏幕底部
points_l[50]  = [x1, 80]   ← 中间，向上移动
points_l[100] = [x2, 20]   ← 接近顶部
points_l[最大] = [x3, 0-5]  ← 终点，屏幕顶部
```

---

## 3️⃣ 提取边界数组 (`l_border[]` / `r_border[]`)

### 数组索引规则
```c
// 在 get_left() 中进行了行号反转
uint16_t row = image_h - 1 - points_l[j][1];  // 反转！
l_border[row] = col;
```

### 索引增长方向
```
l_border数组索引         对应屏幕位置
l_border[0]     ←→    屏幕顶部 (imo的y=119)
l_border[1]     ←→    ↓
l_border[2]     ←→    ↓
    ...              (向下)
l_border[118]   ←→    ↓
l_border[119]   ←→    屏幕底部 (imo的y=0)
```

### 反转对照表
| `points_l[j][1]` (原始y) | 转换后 `row` | `l_border[]` 索引 | 屏幕位置 |
|:------------------------:|:------------:|:-----------------:|:--------:|
| 0 (图像顶部)             | 119          | 119               | 底部     |
| 60 (图像中部)            | 59           | 59                | 中部     |
| 119 (图像底部)           | 0            | 0                 | 顶部     |

**关键点**：
- ✅ `l_border[0]` = 屏幕**顶部**的边界x坐标
- ✅ 索引增大 = **向屏幕下方**
- ✅ 反转的目的：让数组下标小的元素对应图像上方，符合"从下往上处理"的逻辑

---

## 4️⃣ 中线数组 (`center_line[]`)

### 索引方向
```c
center_line[i] = (l_border[i] + r_border[i]) >> 1;
```

**继承 `l_border` 的索引规则**：
- ✅ `center_line[0]` = 屏幕顶部的中线x坐标
- ✅ 索引增大 = **向屏幕下方**

---

## 5️⃣ 绘制时的坐标转换

### 当前绘制代码
```c
// 绘制原始points（完全体）
imo[row][col] = 1;  // 直接使用 points_l 的原始坐标

// 绘制中线
imo[image_h - row][center_line[row]] = 3;  // 再次反转
```

### 坐标流转全过程
```
八邻域爬取 → points_l[i][1] (y从大→小)
    ↓
提取边界  → row = 119 - y (反转)
    ↓
l_border[row] (索引从小→大 = 屏幕从上→下)
    ↓
绘制显示  → imo[119-row] (再次反转回原始坐标)
```

---

## 📊 对比总结表

| 数据结构 | 索引0位置 | 索引增大方向 | 存储坐标系 | 用途 |
|:--------:|:--------:|:----------:|:----------:|:----:|
| `dir_l[]` | **起点(屏幕底端)** | ↑屏幕上方 | 方向编码(0-7) | 生长方向序列 |
| `points_l[][]` | **起点(屏幕底端)** | ↑屏幕上方 | 图像原始坐标(y大→小) | 完整边界点集 |
| `l_border[]` | **屏幕顶部** | ↓屏幕下方 | 反转后坐标 | 每行的边界x值 |
| `center_line[]` | **屏幕顶部** | ↓屏幕下方 | 反转后坐标 | 每行的中线x值 |

### 📍 关键要点

```
dir_l[0] 和 points_l[0]：
  位置：屏幕底端（y≈117）
  含义：八邻域搜索的起点
  
dir_l[最大] 和 points_l[最大]：
  位置：屏幕顶端（y≈0-5）
  含义：八邻域搜索的终点
  
l_border[0]：
  位置：屏幕顶端（对应imo的y=119，经过反转）
  含义：顶部那一行的左边界x坐标
  
l_border[119]：
  位置：屏幕底端（对应imo的y=0，经过反转）
  含义：底部那一行的左边界x坐标
```

### ⚠️ 易混淆点

1. **dir_l[] 和 l_border[] 的索引0含义完全相反**：
   - `dir_l[0]` = 屏幕**底端**
   - `l_border[0]` = 屏幕**顶端**

2. **原因**：l_border 进行了行号反转
   ```c
   uint16_t row = image_h - 1 - points_l[j][1];  // 反转！
   l_border[row] = col;
   ```

3. **记忆技巧**：
   - 带 `points` 和 `dir` 的数组：索引0在底部（符合"从下往上爬取"的直觉）
   - 带 `border` 和 `line` 的数组：索引0在顶部（符合"数组下标小=图像上方"的习惯）

## 🔍 用户实例验证

### 测试图像分析
根据您提供的图像和数据：

```
图像描述：
┌─────────────────────────┐ y=0 (图像顶部)
│ ●●●●                    │ ← 红色左边界延伸到左上角
│   ●●                    │
│     ●                   │
│      ●                  │
│       ●                 │
│        ●                │ ← 左转弯处
│         ●               │
│          ●              │
│           ●             │
│            ●            │ ← 直线向上段
│             ●           │
│              ●          │
│               ●         │
│                ●        │
│                 ●       │
│                  ●      │
│                   ●     │
│                    ●●●  │ ← 起点（底部）
└─────────────────────────┘ y=119 (图像底部)

dir_l 数组映射（⚠️ 记录值 → 实际生长方向）：
索引0-12:   记录[3,3,3,...]     → 实际: 持续向上
索引13-95:  记录[4,4,4,3,4,...] → 实际: 右上为主，偶尔向上
索引96-140: 记录[2,2,1,1,1,...] → 实际: 左转：左上→向左→左下
索引141-170:记录[1,1,0,1,0,...] → 实际: 到达顶部：向左+左下
索引171+:   记录[7,3,5,5,5,...] → 实际: 顶部拐角：向下后调整为向右
```

### ✅ 验证结论

**方向编码规律完全正确！**

1. **起点特征** ✓
   - 记录 `dir_l[0-12] = 3` → 实际生长 seeds_l[4] = {0,-1} → **向上**
   - 符合图像：从底部开始向上爬取

2. **主要爬升** ✓
   - 记录 `dir_l[13-95]` 主要是4，偶尔3
   - 记录4 → 实际 seeds_l[5] = {1,-1} → **右上**
   - 记录3 → 实际 seeds_l[4] = {0,-1} → **向上**
   - 符合图像：持续向右上生长，偶尔纯向上

3. **左转弯道** ✓
   - 记录 `dir_l[96-140]` 出现2和1
   - 记录2 → 实际 seeds_l[3] = {-1,-1} → **左上**
   - 记录1 → 实际 seeds_l[2] = {-1,0} → **向左**
   - 符合图像：在上方区域开始向左水平延伸

4. **到达顶部** ✓
   - 记录 `dir_l[141-170]` 出现0和1
   - 记录0 → 实际 seeds_l[1] = {-1,1} → **左下**
   - 记录1 → 实际 seeds_l[2] = {-1,0} → **向左**
   - 符合图像：已经到达顶部，开始向左和左下

5. **顶部拐角** ✓
   - 记录 `dir_l[171+]` 出现7和5
   - 记录7 → 实际 seeds_l[0] = {0,1} → **向下**
   - 记录5 → 实际 seeds_l[6] = {1,0} → **向右**
   - 表示在顶部左侧遇到边界，从向下调整为向右

---

## 📝 修订说明

**2025-10-25 重要更新**：
- ✅ **发现并验证了方向记录的+1偏移规律**
- ✅ `dir_l[x] = i` 表示在seeds_l[i]方向检测到边界
- ✅ 实际生长方向是 `seeds_l[(i+1) & 7]`
- ✅ 用户观察"记录3=实际向上"完全符合此规律
- ✅ 通过实际图像数据完整验证了所有方向的对应关系
- ✅ 更新了所有文档中的方向说明和可视化图表

---

## 🔧 实际应用示例

### 示例1：判断生长是否向上
```c
// 记录值3表示实际向上生长 (seeds_l[4] = {0,-1})
if (dir_l[i] == 3) {
    // 说明该点在向屏幕上方爬取（主要生长方向）
}

// 记录值4表示实际右上生长 (左线) 或左上生长 (右线)
if (dir_l[i] == 4) {
    // 左线：向右上方移动 seeds_l[5] = {1,-1}
}
```

### 示例2：转换记录值为实际方向
```c
// 获取实际生长方向的seeds索引
uint8_t actual_direction = (dir_l[i] + 1) & 7;
int8_t x_offset = seeds_l[actual_direction][0];
int8_t y_offset = seeds_l[actual_direction][1];

// 示例：dir_l[i] = 3
// actual_direction = (3 + 1) & 7 = 4
// x_offset = seeds_l[4][0] = 0
// y_offset = seeds_l[4][1] = -1
// 含义：向上生长（x不变，y-1）
```

### 示例3：识别弯道特征
```c
// 左弯道检测（左线持续向左）
bool is_left_curve = true;
for (int i = start; i < end; i++) {
    uint8_t actual_dir = (dir_l[i] + 1) & 7;
    // 检查实际方向是否为左上(3)、向左(2)、左下(1)
    if (actual_dir != 3 && actual_dir != 2 && actual_dir != 1) {
        is_left_curve = false;
        break;
    }
}
```

### 示例2：访问特定高度的边界
```c
// 要访问屏幕上方1/3处的左边界
int target_row = image_h / 3;  // l_border索引40（对应imo的y=79）
uint8_t left_x = l_border[target_row];
```

### 示例3：遍历从底到顶的边界
```c
// 使用 l_border 遍历（从顶到底）
for (int row = 0; row < image_h; row++) {
    // row=0是屏幕顶部，row=119是屏幕底部
}

// 使用 points_l 遍历（从底到顶）
for (int i = 0; i < data_stastics_l; i++) {
    // i=0是起点(底部)，i=max是终点(顶部)
    // 但 points_l[i][1] 是递减的
}
```

---

## ⚠️ 注意事项

1. **坐标系混用风险**：
   - `points_l` 使用原始图像坐标
   - `l_border` 使用反转后的索引
   - 绘制时需要注意转换关系

2. **丢线判断**：
   - `l_border[row] == border_min` 且 `left_lost[row] == 1` = 该行左线丢失
   - `r_border[row] == border_max` 且 `right_lost[row] == 1` = 该行右线丢失

3. **十字补线**：
   - `break_num` 使用的是 `points_l[i][1]`（原始y坐标）
   - 补线时操作的是 `l_border[]`（反转后索引）
   - 需要注意坐标转换

---

## 📝 版本信息

- **文件**: `image.c`
- **分支**: RE0with8neighbor
- **日期**: 2025年10月25日
- **说明**: 本文档描述八邻域边界提取算法的坐标系统设计
